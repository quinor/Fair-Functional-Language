Aby zbudować interpreter, należy wykonać make all. Uwaga: to polecenie ściąga Stacka i używa go do
zainstalowania nowego GHC. Nie udało mi się inaczej uruchomić mojego programu na students.

Przykłady kodu (na razie tylko jeden plik) znajdują się w katalogu examples. Nie ma jeszcze
przykładów negatywnych. Zaimplementowane elementy interpretera:
  * silnie typowany rachunek lambda
  * inferencja typów H-M z polimorfizmem
  * explicite zaimplementowana leniwość
  * if będący funkcją (if expr then expr else expr jest tylko lukrem syntaktycznym na wywołanie
    __builtin__if :: Bool -> a -> a)
  * analogicznie operatory będące lukrem syntaktycznym na wywołanie funkcji
  * parser przygotowany na deklaracje własnych operatorów, napisany za pomocą biblioteki Megaparsec

Niezaimplementowane elementy:
  * typy algebraiczne i pattern matching
  * lukier syntaktyczny (np let/lambda z wprowadzonym więcej niż jednym identyfikatorem na raz)
  * obsługa błędów parsera, typecheckera i interpretera
  * klasy, monady, wejście/wyjście


W obecnej wersji program składa się z listy nazwanych wyrażeń (def name = expression). Każde z
nich jest tymczasowo traktowane niezależnie. Przy uruchomieniu są one parsowane i sprawdzane pod
kątem typów, a potem jest wypisywany ich wynik w formie jawnego konstruktora typu Data.

Biblioteka standardowa (zdefiniowana w Interpreter.Primitives) jest ograniczona do
funkcji-wbudowanych. Operatory są jedynie lukrem syntaktycznym na wywołanie funkcji wbudowanych,
dołączanych w postaci biblioteki standardowej na początek każdego programu.
